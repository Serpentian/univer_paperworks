\section{Конфиденциальность и базовые примитивы}

Предыдущий раздел касался только смысла безопасности для симметрических
криптосистем (и расширял наше понятие симметрических криптосистем). В этом
разделе будет рассмотрено, как строить симметрические криптосистемы,
обеспечивающие конфиденциальность, и какие примитивы необходимы для их
построения. В силу Теоремы~7.8 нужно учитывать только атаки с выбранным
открытым текстом (и, следовательно, на данный момент можно также игнорировать
ассоциированные данные). Интегритет будет достигнут в следующем разделе.

\subsection{Потоковые шифры}

Здесь будут рассмотрены так называемые синхронные или аддитивные потоковые
шифры, где \emph{генератор потока ключей} расширяет ключ и вектор инициализации
в строку символов, которая затем добавляется к сообщению (которое
интерпретируется как строка символов). Традиционно потоковые шифры были
бит-ориентированными, но алфавит можно понимать как любую группу.

\begin{tcolorbox}[experiment]
\textbf{Эксперимент для генератора потока ключей выполняется следующим образом:}
\begin{enumerate}[label=\arabic*.,leftmargin=1.5em]
    \item Сэмплируются $b \xleftarrow{r} \{0,1\}$ и $k \xleftarrow{r} K$.
    \item Когда противник посылает запрос длины $l < N$, эксперимент
    сэмплирует $iv \xleftarrow{r} V$, вычисляет
    \[
        f(k, iv, l) = (z_{0,1}, z_{0,2}, \ldots, z_{0,l}),
    \]
    и сэмплирует
    \[
        (z_{1,1}, z_{1,2}, \ldots, z_{1,l})
    \]
    из равномерного распределения на $G^{l}$.
    \item Затем эксперимент посылает $(iv,\ z_{b,1}, z_{b,2}, \ldots, z_{b,l})$ противнику~$A$.
\end{enumerate}
В конце противник выводит бит $b' \in \{0,1\}$.
\end{tcolorbox}

\begin{mylistingtext}{11}
Эксперимент для игры безопасности генератора потока ключей $f : K \times V \to
G^{N}$.
\end{mylistingtext}

\begin{mydefinition}{}{}
Пусть $f : K \times V \to G^N$ является генератором потока ключей.
$(\tau, \ell_c)$-противник против $f$ — это интерактивный алгоритм $A$, который взаимодействует с экспериментом на Листинге 11, делая не более $\ell_c$ запросов к эксперименту, и где время работы противника и эксперимента не превосходит $\tau$.

Преимущество этого противника определяется как
\[
\mathsf{Adv}^{\mathsf{ksg}}_{f}(A)
= 2\lvert \Pr[E] - 1/2 \rvert,
\]
где $E$ — это событие, что бит $b'$ на выходе $A$ равен биту $b$, выбранному экспериментом.
\end{mydefinition}

Будет вычисляться только столько элементов потока ключей, сколько требуется. Поток ключей должен вычисляться некоторым алгоритмом, стоимость которого по существу линейна по числу вычисленных элементов потока.

\textbf{Замечание.} Иногда требуется псевдослучайный генератор $f : K \to G^N$. Поскольку вектора инициализации нет, каждый ключ расширяется в единственный поток ключей. Игра безопасности в этом случае является однозапросной версией игры безопасности генератора потока ключей.

\textbf{Замечание.} Существует более сильное понятие безопасности для генераторов потока ключей, где противнику разрешено задавать используемый вектор инициализации (псевдослучайная функция). Обычно это слишком сильное требование, поскольку оно не нужно и может усложнить проектирование генератора потока ключей. Промежуточным вариантом является указание фиксированной последовательности векторов инициализации, для которой легко проектировать и которая полезна во многих приложениях.

\begin{myexample}{}{}
Пусть $f : K \times V \to G^{N}$ является генератором потока ключей.
Аддитивный потоковый шифр, основанный на $f$, имеет вид
\[
\Sigma = (K,\ \bigcup_{l \le N} G^{l},\ V \times \bigcup_{l \le N} G^{l},\ E,\ D),
\]
где:
\begin{itemize}[leftmargin=1.5em]
    \item Алгоритм шифрования $E$ принимает на вход ключ $k \in K$
    и сообщение $m = m_{1} m_{2} \ldots m_{l}$ для некоторого $l \le N$.
    Он сэмплирует $\mathit{iv} \xleftarrow{r} V$, вычисляет
    \[
        (z_{1}, z_{2}, \ldots, z_{l}) \leftarrow f(k, \mathit{iv}, l),
    \]
    и $w_{i} = m_{i} + z_{i}$ для $i = 1,2,\ldots,l$, после чего выводит
    $c = (\mathit{iv},\ w_{1} w_{2} \ldots w_{l})$.

    \item Алгоритм расшифрования $D$ принимает на вход ключ $k \in K$
    и шифротекст $c = (\mathit{iv},\ w_{1} w_{2} \ldots w_{l})$.
    Он вычисляет
    \[
        (z_{1}, z_{2}, \ldots, z_{l}) \leftarrow f(k,\ \mathit{iv},\ l),
    \]
    и $m_{i} = w_{i} - z_{i}$ для всех $i = 1,2,\ldots,l$,
    после чего выводит $m = m_{1} m_{2} \ldots m_{l}$.
\end{itemize}
\end{myexample}

\begin{myexercise}{}{}
Пусть $\Sigma$ — аддитивный потоковый шифр, основанный на генераторе потока
ключей $f : K \times V \to G^{N}$. Пусть $A$ — $(\tau,\ \ell_{c},\ \ell_{e},\
0)$-противник против неразличимости для $\Sigma$. Показать, что существует
$(\tau',\ \ell_{c} + \ell_{e})$-противник $B$ против генератора потока ключей
$f$, где $\tau'$ по существу равен $\tau$, и
\[
\mathsf{Adv}^{\mathsf{ind\mbox{-}cpa}}_{\Sigma}(A)
   \le
\mathsf{Adv}^{\mathsf{ksg}}_{f}(B)
   + 2\,\frac{(\ell_{c} + \ell_{e})^{2}}{|V|}.
\]
\end{myexercise}

\textbf{Замечание.} Дополнительный член в границе преимущества противника
возникает из-за возможных коллизий вектора инициализации. Если использовать
более сильные notions безопасности для генератора потока ключей, такие как
описанные в замечании перед примером, можно построить потоковые шифры с более
жёсткими гарантиями безопасности, используя фиксированную последовательность
векторов инициализации. Однако это приводит к stateful-шифру. Иногда это вполне
практично, но иногда — нет.

\begin{myexercise}{}{}
Повторить предыдущее упражнение, но для R-random-безопасности, определённой в Разделе~1.3.
\end{myexercise}

\subsection{Псевдослучайные перестановки и функции}

Блочные шифры, также называемые псевдослучайными перестановками, являются
чрезвычайно полезными примитивами в симметричной криптографии. Блочный шифр
представляет собой семейство перестановок на некотором множестве.

Связанным понятием является псевдослучайная функция, которую мы уже видели в
ослабленной форме — генератор потока ключей. Псевдослучайная функция
(семейство) — это просто семейство функций, индексированное множеством ключей.

\begin{mydefinition}{}{}
Псевдослучайное функциональное (PRF) семейство — это функция
\[
    f : K \times S \to T.
\]
\end{mydefinition}

Идея этих игр безопасности состоит в том, что эксперимент предоставляет
противнику доступ либо к функции/перестановке из псевдослучайного семейства,
либо к случайной функции/перестановке. Для простоты эксперимент с
перестановками вычисляет как перестановку, так и её обратную для каждого
запроса.

\begin{tcolorbox}[experiment]
\textbf{Эксперимент PRF выполняется следующим образом:}

\begin{enumerate}[label=\arabic*.,leftmargin=1.5em]
    \item Сэмплировать $b \xleftarrow{r} \{0,1\}$ и $k \xleftarrow{r} K$. Положить $C_{0} = C_{1} = \varnothing$.
    \item Когда противник посылает запрос $s \in S$ (evaluate), выполнить:
    \begin{enumerate}[label=\alph*),leftmargin=1.5em]
        \item Если $s \notin C_{1}$, сэмплировать $u \xleftarrow{r} T$ и добавить $s$ в $C_{1}$ и $(s,u)$ в $C_{0}$.
        \item Найти $(s,u_{1}) \in C_{0}$. Вычислить $u_{0} \leftarrow f(k,s)$. Отправить $u_{b}$ противнику.
    \end{enumerate}
\end{enumerate}

В конце противник выводит $b' \in \{0,1\}$.
\end{tcolorbox}

\begin{mylistingtext}{12}
Эксперимент для игры безопасности PRF для псевдослучайной функции $f : K \times S \to T$.
\end{mylistingtext}

\begin{mydefinition}{}{}
Пусть $f : K \times S \to T$ — PRF. $(\tau, l_c)$-противник против $f$ — это
интерактивный алгоритм $A$, который взаимодействует с экспериментом на
Листинге 12, делая не более $l_c$ запросов к эксперименту, причём время работы
противника и эксперимента не превышает $\tau$.

Преимущество этого противника определяется как
\[
    \mathsf{Adv}^{\mathrm{prf}}_{f}(A)
    = 2\left|\Pr[E] - \frac12\right|,
\]
где $E$ — событие, что бит $b'$ на выходе $A$ совпадает с битом $b$, выбранным экспериментом.
\end{mydefinition}

\begin{mydefinition}{}{}
Пусть $\pi, \pi^{-1} : K \times S \to S$ образуют блочный шифр. $(\tau,
l_c)$-противник против $(\pi,\pi^{-1})$ — это интерактивный алгоритм $A$,
взаимодействующий с экспериментом на Листинге 13, делая не более $l_c$
запросов к эксперименту, причём время работы противника и эксперимента не
превышает~$\tau$.

Преимущество этого противника определяется как
\[
    \mathsf{Adv}^{\mathrm{prp}}_{(\pi,\pi^{-1})}(A)
    = 2\left|\Pr[E] - \frac12\right|,
\]
где $E$ — событие, что бит $b'$ на выходе $A$ совпадает с битом $b$, выбранным
экспериментом.
\end{mydefinition}

\begin{tcolorbox}[experiment]
\textbf{Эксперимент для блочного шифра выполняется следующим образом:}

\begin{enumerate}[label=\arabic*.,leftmargin=1.5em]
    \item Сэмплировать $b \xleftarrow{r} \{0,1\}$ и $k \xleftarrow{r} K$. Положить $C_{0} = C_{1} = C_{2} = \varnothing$.
    \item Когда противник посылает запрос $s \in S$ (evaluate), выполнить:
    \begin{enumerate}[label=\alph*),leftmargin=1.5em]
        \item Если $s \notin C_{1}$, сэмплировать $u \xleftarrow{r} S \setminus C_{2}$ и добавить $(s,u)$ в $C_{0}$, $s$ в $C_{1}$ и $u$ в $C_{2}$.
        Если $s \notin C_{2}$, сэмплировать $v \xleftarrow{r} S \setminus C_{1}$ и добавить $(v,s)$ в $C_{0}$, $s$ в $C_{2}$ и $v$ в $C_{1}$.
        \item Найти $(s,u_{1}) \in C_{0}$ и $(v_{1},s) \in C$. Вычислить $u_{0} \leftarrow \pi^{-1}(k,s)$ и $v_{0} \leftarrow \pi(k,s)$.
        Отправить $(u_{b}, v_{b})$ противнику.
    \end{enumerate}
\end{enumerate}

В конце противник выводит $b' \in \{0,1\}$.
\end{tcolorbox}

\begin{mylistingtext}{13}
Эксперимент для игры безопасности блочного шифра $(\pi,\pi^{-1}) : K \times S \to S$.
\end{mylistingtext}

\textbf{Замечание.}
Существует более слабое понятие псевдослучайной функции (иногда называемое
слабой псевдослучайной функцией), когда противник не выбирает точку, в которой
вычисляется функция. Это по сути то же, что генератор потока ключей, за
исключением того, что генератор потока ключей имеет маленькую область
определения и очень большую область значений, тогда как для псевдослучайных
функций часто наоборот. Область значений генератора потока ключей также имеет
очень специальную форму, тогда как псевдослучайная функция может иметь более
сложное множество значений.

\textbf{Замечание.}
Проектирование псевдослучайных функций и перестановок выходит за рамки этой
книги. Тем не менее псевдослучайные перестановки или блочные шифры имеют долгую
историю. Считается, что известны хорошие блочные шифры.

Псевдослучайные функции получили меньше прямого внимания, хотя современные
стандарты хеширования дают некоторые очень полезные разработки. Функции сжатия
многих распространённых хеш-функций подходят как псевдослучайные функции для
некоторых целей. Конструкция HMAC также полезна, если требуется функция с более
крупной областью определения. Другая общая стратегия
основана на методе \emph{forthwidth}.

\textbf{Использование блочных шифров в качестве псевдослучайных функций}
Псевдослучайная перестановка выглядит как случайная перестановка.
Псевдослучайная функция выглядит как случайная функция. Но до тех пор, пока
исследуется не слишком много значений, случайная перестановка выглядит как
случайная функция. Таким образом, если имеется псевдослучайная перестановка, её
можно рассматривать как псевдослучайную функцию, пока она вычисляется не на
слишком большом числе точек.

Сэмплирование случайной функции и последующее вычисление её значений на
различных точках эквивалентно независимому выбору элементов из равномерного
распределения. Точно так же сэмплирование случайной перестановки и вычисление
её значений на различных точках эквивалентно независимому выбору элементов из
равномерного распределения, с тем лишь условием, что выбранные элементы
различны.

\begin{tcolorbox}[experiment]
Эксперимент по различению случайных функций и случайных перестановок
с противником~$A$ выполняется следующим образом:

\begin{enumerate}[label=\arabic*.,leftmargin=1.5em]
    \item Сэмплировать бит $b \xleftarrow{r} \{0,1\}$. Положить $C_0 = C_1 = C_2 = \varnothing$.

    \item Когда противник посылает запрос $s \in S$ (evaluate), выполнить:
    \begin{enumerate}[label=\alph*),leftmargin=1.5em]
        \item Если $s \notin C_1$, сэмплировать $u_0 \xleftarrow{r} S$ и
              $u_1 \xleftarrow{r} S \setminus C_2$. Добавить $(s, u_b)$ в $C_0$,
              $s$ в $C_1$ и $u_b$ в $C_2$.

        \item Найти $(s, u) \in C_0$. Отправить $u$ противнику~$A$.
    \end{enumerate}
\end{enumerate}

В конце противник выводит бит $b' \in \{0,1\}$.
\end{tcolorbox}

\begin{mylistingtext}{14}
Эксперимент для леммы 2.1
\end{mylistingtext}

\begin{mylemma}{}{}
Пусть $A$ — интерактивный алгоритм, который взаимодействует с экспериментом из Листинга 14 и делает не более $l_c$ запросов. Тогда
\[
2\lvert \Pr[E] - \tfrac12 \rvert \le \frac{l_c^{\,2}}{2\lvert S\rvert},
\]
где $E$ — событие, что $b' = b$ в конце работы противника.
\end{mylemma}

\begin{proof}
Эксперимент по существу выбирает две последовательности элементов из $S$,
одну с возвращением, а другую без возвращения. Обозначим через $F$ событие,
что последовательность, выбранная с возвращением, состоит из различных
элементов.

Утверждение о парадоксе дней рождения говорит, что последовательность,
выбранная с возвращением, будет состоять из различных элементов, кроме как
с вероятностью, ограниченной величиной $l_c^{\,2}/(2\lvert S\rvert)$, то есть
\[
\Pr[\neg F] \le \frac{l_c^{\,2}}{2\lvert S\rvert}.
\]

Если все элементы, выбранные с возвращением, различны, то они распределены
точно так же, как элементы, выбранные без возвращения, следовательно,
\[
\Pr[E \mid F] = \tfrac12.
\]

Вычисляется:
\[
2\lvert \Pr[E] - \tfrac12 \rvert
= 2\bigl\lvert \Pr[E\mid F](1 - \Pr[\neg F]) + \Pr[E\mid \neg F]\Pr[\neg F] - \tfrac12 \bigr\rvert
\]
\[
= 2\lvert (\Pr[E\mid \neg F] - \tfrac12)\Pr[\neg F] \rvert
\le \Pr[\neg F].
\]
Тем самым утверждение доказано.
\end{proof}

Лемма выше показывает, что пока вычисления выполняются не на слишком
многих точках, случайно выбранная функция неотличима от случайно выбранной
перестановки. Поскольку блочный шифр должен быть трудноотличим от случайной
перестановки (с инверсией), а псевдослучайная функция — от случайной функции,
то по транзитивности следует, что блочный шифр (если не использовать его обратную
функцию) должен быть трудноотличим от случайной функции.

\begin{mytheorem}{}{}
(Лемма о переключении между PRP и PRF) Пусть $(\pi,\pi^{-1})$ — блочный шифр на
множестве $S$. Пусть $A$ — $(\tau, l_c)$-противник против $\pi$,
рассматриваемого как PRF. Тогда существует $(\tau', l_c)$-противник $B$ против
$(\pi,\pi^{-1})$, рассматриваемого как блочный шифр, где $\tau'$ по существу
равен $\tau$, и
\[
\mathsf{Adv}^{\mathrm{prf}}_{\pi}(A)
\;\le\;
\mathsf{Adv}^{\mathrm{prp}}_{(\pi,\pi^{-1})}(B)
\;+\;
\frac{l_c^{\,2}}{2\lvert S\rvert}.
\]
\end{mytheorem}

\begin{proof}
Сначала определяется симулятор $\mathsf{Sim}$ следующим образом:
когда симулятор получает запрос от $A$, он пересылает запрос в эксперимент
блочного шифра. Когда он получает ответ $(u', u'')$, он пересылает $u'$ алгоритму $A$.
Противник $B$ запускает копию $\mathsf{Sim}$ и $A$, и когда $A$ выводит бит $b'$,
$B$ также выводит $b'$. Если $A$ превышает свои ограничения, $B$ самплирует
$b' \xleftarrow{r} \{0,1\}$ и выводит его.

Далее вводятся события. Пусть $E_\beta$ — событие, что $A$ выводит $1$ при
взаимодействии с PRF-экспериментом, где $b=\beta$. Пусть $F_\beta$ — событие, что
$B$ выводит $1$ при взаимодействии с экспериментом блочного шифра, где $b=\beta$.

По Лемме~1.1:
\[
\mathsf{Adv}^{\mathrm{prf}}_{\pi}(A) = \lvert \Pr[E_0] - \Pr[E_1] \rvert,
\qquad
\mathsf{Adv}^{\mathrm{prp}}_{(\pi,\pi^{-1})}(B)
   = \lvert \Pr[F_0] - \Pr[F_1] \rvert.
\]

По непосредственной проверке, когда $b=0$, поведение $A$ во взаимодействии
с PRF-экспериментом полностью совпадает с поведением $B$ во взаимодействии
с экспериментом блочного шифра. Следовательно,
\[
\Pr[E_0] = \Pr[F_0].
\]

Далее, также по непосредственной проверке, поведение $A$ во взаимодействии
с PRF-экспериментом при $b=1$ совпадает с поведением $A$ во взаимодействии
с экспериментом из Листинга 14 при $b=0$. Аналогично, поведение $A$,
встроенного в $B$, при взаимодействии с экспериментом блочного шифра при
$b=1$ совпадает с поведением $A$ во взаимодействии с экспериментом из
Листинга 14 при $b=1$. Леммы~1.1 и~2.1 дают:
\[
\lvert \Pr[E_1] - \Pr[F_1] \rvert
\;\le\;
\frac{l_c^{\,2}}{2\lvert S\rvert}.
\]

Наконец, вычисляется:
\[
\mathsf{Adv}^{\mathrm{prf}}_{\pi}(A)
= \lvert \Pr[E_0] - \Pr[E_1] \rvert
\]
\[
= \lvert
\Pr[E_0] - \Pr[F_0]
+ \Pr[F_0] - \Pr[F_1]
+ \Pr[F_1] - \Pr[E_1]
\rvert
\]
\[
\le
\lvert \Pr[F_0] - \Pr[F_1] \rvert
\;+\;
\lvert \Pr[F_1] - \Pr[E_1] \rvert.
\]

Таким образом, утверждение доказано.
\end{proof}


\subsection{Два построения}

Ранее был рассмотрен режим счётчика (counter mode) для блочных шифров, но эта
конструкция одинаково хорошо работает и для PRF.

\begin{myexample}{}{}
Пусть $f$ — функция из $K \times V \times \{1,2,\ldots,N\}$ в некоторую
конечную группу $G$. Для любых $iv \in V$ и $k \in K$ режим счётчика
(CTR) определяется функцией
\[
    \mathrm{ctr}_\pi : K \times V \to G^N,
    \qquad
    \mathrm{ctr}_\pi(k, iv) = z_1 z_2 \dots z_N,
\]
где
\[
    z_i = \pi(k, (iv, i)), \qquad 1 \le i \le N.
\]
\end{myexample}

\begin{myexercise}{}{}
Доказать, что любого противника против генератора ключевого потока
в режиме счётчика можно превратить в PRF-противника против $f$
с той же выгодой и практически тем же временем выполнения.
\end{myexercise}

\textbf{Замечание.} Приведённая конструкция по существу показывает,
как построить PRF с более крупным ко-доменом ценой уменьшения
домена. Позднее будет рассмотрено, как увеличить домен PRF.

Режим сцепления блоков (cipher-block chaining, CBC) из Примера~1.9 —
удобный способ превратить блочный шифр в симметрическую криптосистему.

\begin{myexercise}{}{}
Пусть $(\pi, \pi^{-1})$ — блочный шифр над группой $G$.
Пусть $R$ — семейство шумовых распределений, где $R_\ell$ —
равномерное распределение на $G^{\ell+1}$.
Доказать, что любого R-random противника с выбранным открытым текстом
против режима CBC можно превратить в противника против блочного шифра
с практически тем же временем выполнения. Если $l_c$ — число
зашифрованных сообщений, а $l$ — их суммарная длина, то разность выгод
ограничена величиной
\[
    \frac{(l_c + l)^2}{|G|}.
\]
\end{myexercise}

