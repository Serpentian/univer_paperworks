\section{Персистентный GC}

Следующим требованием заказчика было сохранение данных для анонимных реплик. Эта функциональность будет обеспечиваться персистентным GC, описание которого приводится в данной части.

Это требование вытекает из того факта, что репликация идет только из xlog файлов. Мастер постоянно отслеживает, кому и какие xlog файлы нужны в репликасете, и не удаляет их. Однако для анонимных реплик это не делается, так как они не входят в репликасет. Когда xlog файлы, которые еще не были среплицированы на анонимную реплику, удаляются, то реплика вынуждена делать процесс ребутстрапа, включающий в себя выкачивание состояния БД с нуля. Это приводит к существенному понижению доступности анонимной реплики.

Было принято решение полностью переделать систему GC, так как до этого состояние GC находилось в памяти и после перезапуска узел не знал, какие файлы нужно сохранять, а какие можно удалять. Это приводило к тому, что узел был вынужден ждать подключения всех реплик к текущему узлу.

\textbf{Локальный спейс \_gc\_consumers}

Теперь состояние GC сохраняется в новом локальном спейсе \_gc\_consumers, который имеет следующий формат, приведенный в таблице~\ref{tab:tab1}.

\begin{table}
    \centering
    \caption{Формат \_gc\_consumers}
    \begin{tabular}{|r|c|l|}\hline
        Поле & Имя & uuid \\ \hhline{~--}
             & Тип & string \\ \hline
        Поле & Имя & vclock \\ \hhline{~--}
             & Тип & map    \\ \hline
    \end{tabular}
    \label{tab:tab1}
\end{table}

UUID используется вместо id реплики, так как отныне xlog файлы могут также сохраняться для анонимных реплик, у которых id равно 0. Объединение всех анонимных реплик в одну строку не является оптимальным решением.

Для каждой из реплик создается GC consumer, который отслеживает, до какого vclock реплика уже получила данные. Их реализация (в памяти) остается без изменений, однако теперь они создаются\/удаляются с использованием on\_replace триггера спейса \_gc\_consumers. Во время запуска узла они будут созданы автоматически.

\textbf{Подключение обычных реплик}

Для обычных реплик появляется новый on\_replace триггер на спейс \_cluster, в который реплика вставляется после окончания фазы initial JOIN. Этот тригер вставляет кортеж в спейс \_gc\_consumers, что вызовет создание GC consumer для данной реплики. Удаление реплики из спейса \_cluster вызывает удаление записи из \_gc\_consumers. Прямое удаление реплики из \_gc\_consumers запрещено.

Таким образом, процесс подключение неанонимной реплики выглядит следующим образом:

\begin{enumerate}
    \item Реплика хочет быть присоединенной к репликасету и отправляет IPROTO\_JOIN.
    \item Мастер создает read-view, посылает его реплике. Реплика вставляется в спейс \_cluster, on\_replace триггер создает запись в \_gc\_consumers. Отныне файлы сохраняются для этой реплики.
    \item Реплика входит в фазу FOLLOW.
\end{enumerate}

\textbf{Подключение анонимных реплик}

Так как анонимная реплика нигде не сохраняется, как это делается для обычных реплик (\_cluster), нам необходимо добавить новый флаг в IPROTO\_FETCH\_SNAPSHOT: IPROTO\_IS\_PERSISTENT\_GC. По умолчанию флаг равен false, GC consumer-ы для анонимных реплик не создаются. Также этот флаг необходимо добавить в IPROTO\_SUBSCRIBE (инициация фазы FOLLOW).

Таким образом, процесс подключения анонимной реплики выглядит следующим образом:

\begin{enumerate}
    \item Реплика отправляет IPROTO\_FETCH\_SNAPSHOT с флагом IPROTO\_IS\_PERSISTENT\_GC. Реплика получает в ответ read-view или файл. Отныне xlog файлы хранятся для нее.
    \item Реплика отправляет IPROTO\_SUBSCRIBE с тем же флагом.
\end{enumerate}

Однако мы не можем позволить таким GC consumer-ам существовать вечно, как это сделано для обычных реплик. Иначе место на диске может быть быстро израсходовано. А потому добавляется новая опция конфигурирования: wal\_anon\_gc\_timeout. Она показывает, сколько секунд живет GC consumer, после момента, когда мы в последний раз общались с репликой.
